<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Coding Journal</title><link>http://shmulik-klein.github.io/posts/</link><description>Recent content in Posts on Coding Journal</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>&amp;copy; Copyright 2022, Shmulik Klein</copyright><lastBuildDate>Mon, 30 May 2022 11:13:37 +0200</lastBuildDate><atom:link href="http://shmulik-klein.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Transactions Isolation #1: Dirty Read</title><link>http://shmulik-klein.github.io/posts/transaction_isolation_1/</link><pubDate>Mon, 30 May 2022 11:13:37 +0200</pubDate><guid>http://shmulik-klein.github.io/posts/transaction_isolation_1/</guid><description>&amp;ldquo;Don&amp;rsquo;t they know we&amp;rsquo;re so afraid? Isolation&amp;rdquo; Jonny Cash
// If someone else will try to update the same data concurrently, then the transaction would behave differently depends on its isolation level.
Reading Gets Dirty When using the lowest isolation level - READ_UNCOMITTED, a phenomena called Dirty Read can take place. In this phenomena one transacation can see another transaction uncommited changes. Here is a Go example:
func main() { db, err := sql.</description></item></channel></rss>